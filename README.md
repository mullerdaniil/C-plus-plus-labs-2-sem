# Условия
https://drive.google.com/drive/folders/1jmmZsH7u3udkW3QCbpuSHM5DdE1D5TZW
___

### №1. ООП. Классы. Наследование
Спроектировать и реализовать следующие классы:
1. Точка
2. Ломаная
3. Замкнутая ломаная
4. Многоугольник
5. Треугольник
6. Трапеция
7. Правильный многоугольник

Для каждого из классов реализовать следующие методы:
1. Конструктор(ы)
2. Конструктор копирования
3. Оператор присваивания
4. Расчет периметра, если применимо
5. Расчет площади, если применимо
6. Другие приватные и публичные метода по усмотрению.
Организовать иерархию классов, там, где это имеет смысл.
!Подумать. Какие объекты этих классов могут быть объединены в один массив, где применим динамический полиморфизм? Продемонстрировать это.

___

### №2. Классы. Перегрузка операторов
Спроектировать и реализовать класс для описания сущности многочлен (полином), раздела математики - Алгебра.
Реализовать конструктор(ы), конструктор копирования, деструктор, а также следующие операторы:
1. =
2. ==, !=
3. +, - (унарный и бинарный), +=, -=
4. * , / (на число), *=, /=
5. <<, >>
6. [] (для получения коэффициента i-го члена)
##### Доп. задание
    O(k), где k - число различных коэффициентов. Например x^10000000 не должен занимать 10000000 * sizeof(...) байтов.

___
### №3. Анализ данных
На основании данных об остановках обещесвенного транспорта
http://data.gov.spb.ru/opendata/7830001067-transport_station/ (можно скачать в xml)
Определить:
1. Маршрут с наибольшим количеством остановок по отдельными видам транспорта
2. Наиболее длинный маршрут (основывая на координатах) по отдельным видам транспорта
3. Улицу с наибольшим числом остановок
Для извлечения данных из xml-файла воспользоваться библиотекой pugixml, либо любым аналогом.
Для хранения и подсчета статистики, спроектировать и реализовать структуры данных, обеспечивающие оптимальную алгоритмическую сложность расчетов и не избыточность по памяти.

___
### №4. STL. Алгоритмы. Итераторы
Требуется реализовать следующие обобщенные алгоритмы.
1. all_of - возвращает true, если все элементы диапазона удовлетворяют некоторому предикату. Иначе false
2. any_of - возвращает true, если хотя бы один из элементов диапазона удовлетворяет некоторому предикату. Иначе false
3. none_of - возвращает true, если все элементы диапазона не удовлетворяют некоторому предикату. Иначе false
4. one_of - возвращает true, если ровно один элемент диапазона удовлетворяет некоторому предикату. Иначе false
5. is_sorted - возвращает true, если все элементы диапазона находятся в отсортированном порядке относительно некоторого критерия
6. is_partitioned - возвращает true, если в диапазоне есть элемент, делящий все элементы на удовлетворяющие и не удовлетворяющие некоторому предикату. Иначе false.
7. find_not - находит первый элемент, не равный заданному
8. find_backward - находит первый элемент, равный заданному, с конца
9. is_palindrome - возвращает true, если заданная последовательность является палиндромом относительно некоторого условия. Иначе false.

Каждый алгоритм должен быть выполнен в виде шаблонной функции, позволяющей взаимодействовать со стандартными контейнерами STL с помощью итераторов. Предикаты, условия, операторы сравнения должны быть параметризованы.
При сдаче работы требуется продемонстрировать работу алгоритмов как на стандартных, так и на пользовательских типах данных, например CPoint, CRational.

_____
### №5. STL. Контейнеры
Реализовать кольцевой буфер в виде stl-совместимого контейнера (например, может быть использован с стандартными алгоритмами), обеспеченного итератором произвольного доступа. Реализация не должна использовать ни одни из контейнеров STL. Буфер должен обладать следующими возможностями:
1. Вставка и удаление в конец
2. Вставка и удаление в начало
3. Доступ в конец, начало
4. Доступ по индексу
5. Изменение капасити

##### Доп. задание
    Нужно реализовать оптимизированную версию кольцевого буфера (см. https://www.boost.org/doc/libs/1_61_0/doc/html/boost/circular_buffer_idp9489760.html)
    Эта реализация предполагает, что буфер изначально имеет размер не max_capacity, а например 2. И он постепенно расширяется до размера max_capacity по аналогии с  std::vector. Далее он ведет себя как уже обычный кольцевой буфер. Благодаря этому достигается O(n) памяти в любой момент работы


___
### №6. Кубик Рубика

Спроектировать и реализовать программу, имитирующую сборку Кубика Рубика 3x3.

К программе предъявляются следующие функциональные требования:
- Сохранение и чтение состояния кубика рубика из файла
- Проверка корректности текущего состояния (инвариант состояний кубика)
- Вывод в консоль текущего состояния
- Вращение граней кубика рубика с помощью вводимых команд
- Генерация случайного состояния Кубика Рубика, корректного с точки зрения инварианта состояний
- Нахождения “решения” для текущего состояния в виде последовательности поворотов граней
Нефункциональные требования:
- Программа должны быть спроектирована, с использованием ОПП
- Логические сущности должны быть выделены в отдельный классы

Критерии оценки:
- Логично выстроенная архитектура приложения
- Применение возможностей языка программирования С++ включая стандартную библиотеку

##### Доп. задание
    Реализовать графический интерфейс приложения, с использование OpenGL Utility Toolkit
___